<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>히썹 눈썹 디자인 미리보기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(to bottom, #ffe9d6, #fff3e6);
      display: flex; justify-content: center; padding: 20px;
    }
    .container { display: flex; flex-direction: row; align-items: flex-start; max-width: 1200px; width: 100%; gap: 24px; }
    .controls {
      width: 300px; background: #fff9f3; padding: 20px; border-radius: 12px;
      box-shadow: 0 0 10px rgba(0,0,0,0.05);
    }
    .controls h1 { color: #f2792b; font-size: 20px; margin-bottom: 20px; text-align: center; }
    .controls label { display:block; font-size: 14px; font-weight: bold; color: #333; margin-top:8px; }
    .controls input[type="file"] { margin: 10px 0 6px; display:block; }
    .controls input[type="range"] { width: 100%; margin: 6px 0 10px; }
    .controls input[type="color"] {
      width: 35px; height: 35px; border: none; border-radius: 50%; margin: 6px 0 12px; padding: 0;
    }
    canvas { border: 4px solid #f2792b; border-radius: 16px; background-color: #fff; width: 500px; height: 600px; }
    button {
      background-color: #f2792b; color: white; border: none; padding: 8px 14px;
      font-size: 14px; border-radius: 6px; cursor: pointer;
    }
    button:hover { background-color: #d25e1d; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .muted { font-size: 12px; color: #666; margin-top: 8px;}
    @media (max-width: 900px){
      .container{ flex-direction: column; align-items: center; }
      canvas { width: 90vw; height: calc(90vw*1.2); max-width: 500px; max-height: 600px; }
    }
  </style>

  <!-- ==== (0) 반드시 opencv.js 이전에 Module 콜백 선언 ==== -->
  <script>
    let mpReady = false, cvReady = false;
    function updateReady() {
      const ready = mpReady && cvReady;
      const statusEl = document.getElementById('status');
      const eraseBtn = document.getElementById('eraseBtn');
      if (statusEl) statusEl.textContent = ready ? '준비 완료' : '모델 로딩 중...';
      if (eraseBtn) eraseBtn.disabled = !ready;
    }
    window.Module = {
      onRuntimeInitialized() { cvReady = true; updateReady(); }
    };
  </script>

  <!-- ==== (1) OpenCV.js는 동기 로드 (async 금지) ==== -->
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>

  <!-- ==== (2) MediaPipe FaceMesh + 연결 상수 ==== -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh_connections.js"></script>
</head>
<body>
  <div class="container">
    <div class="controls">
      <h1>히썹 눈썹 디자인 미리보기</h1>

      <label>얼굴 이미지 업로드</label>
      <input type="file" id="faceInput" accept="image/*" />

      <label>눈썹 이미지(PNG/JPG)</label>
      <input type="file" id="browInput" accept="image/*" />

      <label>눈썹 투명도</label>
      <input type="range" id="alphaSlider" min="0" max="255" value="255" />

      <label>눈썹 색상 선택</label>
      <input type="color" id="colorPicker" />

      <div class="row">
        <button id="resetBtn">리셋</button>
        <button id="eraseBtn" disabled>눈썹 지우기</button>
        <button id="undoBtn">되돌리기</button>
      </div>
      <div class="muted" id="status">모델 로딩 중...</div>
    </div>

    <canvas id="canvas" width="500" height="600"></canvas>
  </div>

  <!-- ==== (3) 앱 스크립트 ==== -->
  <script>
    // === A. DOM & 캔버스 ===
    const faceInput   = document.getElementById("faceInput");
    const browInput   = document.getElementById("browInput");
    const alphaSlider = document.getElementById("alphaSlider");
    const colorPicker = document.getElementById("colorPicker");
    const resetBtn    = document.getElementById("resetBtn");
    const eraseBtn    = document.getElementById("eraseBtn");
    const undoBtn     = document.getElementById("undoBtn");
    const statusEl    = document.getElementById("status");
    const canvas      = document.getElementById("canvas");
    const ctx         = canvas.getContext("2d");

    // === B. 상태 ===
    let faceImg = null;
    let originalFaceSrc = null;       // 업로드 직후 얼굴 원본
    let faceUndoStack = [];           // 인페인팅 전 스냅샷
    const MAX_UNDO = 10;

    let browImg = null;
    let originalBrowImg = null;
    let browMaskCache = null;         // 눈썹 마스크 캐시 (Uint8)
    let browPos   = { x: canvas.width / 2, y: canvas.height / 2 };
    let browScale = 1.0;
    let browAngle = 0;
    let isDragging = false;
    let offset = { x: 0, y: 0 };
    let colorApplied = false;

    // === C. 초기화: FaceMesh ===
    let faceMesh = null;
    initFaceMesh();
    function initFaceMesh() {
      if (eraseBtn) eraseBtn.disabled = true;
      faceMesh = new FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
      });
      faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
        selfieMode: false
      });
      mpReady = true;
      updateReady();
    }
    function detectLandmarks(imageElOrCanvas) {
      return new Promise((resolve, reject) => {
        if (!faceMesh) return reject(new Error("FaceMesh not ready"));
        faceMesh.onResults((res) => {
          resolve(res && res.multiFaceLandmarks && res.multiFaceLandmarks[0] ? res.multiFaceLandmarks[0] : null);
        });
        faceMesh.send({ image: imageElOrCanvas }).catch(reject);
      });
    }

    // === D. 유틸 ===
    function removeWhite(img) {
      const c = document.createElement("canvas");
      c.width = img.width; c.height = img.height;
      const cctx = c.getContext("2d");
      cctx.drawImage(img, 0, 0);
      const id = cctx.getImageData(0, 0, c.width, c.height);
      const data = id.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i+1], b = data[i+2];
        if (r > 220 && g > 220 && b > 220) data[i+3] = 0;   // 흰 배경 투명화
      }
      cctx.putImageData(id, 0, 0);
      const out = new Image();
      out.src = c.toDataURL();
      return out;
    }

    async function buildBrowMask(img) {
      // 1) 알파 우선
      let c = document.createElement("canvas");
      c.width = img.width; c.height = img.height;
      let cctx = c.getContext("2d");
      cctx.drawImage(img, 0, 0);
      let id = cctx.getImageData(0, 0, c.width, c.height);
      const data = id.data;
      let mask = new Uint8ClampedArray(id.width * id.height);

      let alphaSum = 0;
      for (let i = 0, j = 0; i < data.length; i += 4, j++) {
        const a = data[i+3]; alphaSum += a;
        mask[j] = a > 10 ? 255 : 0;
      }
      if (alphaSum > id.width * id.height * 10) return mask; // PNG 등 투명 배경

      // 2) JPG 등 불투명: OpenCV로 밝기 기반 세그멘트
      let mat = cv.matFromImageData(id);
      let hsv = new cv.Mat(); let chan = new cv.MatVector(); let v = new cv.Mat();
      cv.cvtColor(mat, hsv, cv.COLOR_RGBA2RGB);
      cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
      cv.split(hsv, chan);
      v = chan.get(2);
      let inv = new cv.Mat();
      cv.threshold(v, inv, 200, 255, cv.THRESH_BINARY_INV); // 밝은 배경 제거
      let kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3,3));
      cv.morphologyEx(inv, inv, cv.MORPH_OPEN, kernel);
      cv.morphologyEx(inv, inv, cv.MORPH_CLOSE, kernel);
      const mdata = inv.data;
      for (let i = 0; i < mask.length; i++) mask[i] = mdata[i];
      mat.delete(); hsv.delete(); chan.delete(); v.delete(); inv.delete(); kernel.delete();
      return mask;
    }

    function applyColorToBrow(hex) {
      if (!originalBrowImg) return;
      const c = document.createElement("canvas");
      c.width = originalBrowImg.width; c.height = originalBrowImg.height;
      const cctx = c.getContext("2d");
      cctx.drawImage(originalBrowImg, 0, 0);
      const id = cctx.getImageData(0, 0, c.width, c.height);
      const data = id.data;

      if (!browMaskCache) {
        // removeWhite 결과 기준으로 마스크 만들기 (fallback)
        const cleaned = removeWhite(originalBrowImg);
        const tc = document.createElement("canvas");
        tc.width = cleaned.width; tc.height = cleaned.height;
        const tctx = tc.getContext("2d");
        tctx.drawImage(cleaned, 0, 0);
        const iad = tctx.getImageData(0,0,tc.width,tc.height).data;
        browMaskCache = new Uint8ClampedArray(tc.width*tc.height);
        for (let i=0,j=0;i<iad.length;i+=4,j++) browMaskCache[j] = iad[i+3] > 10 ? 255 : 0;
      }

      const rT = parseInt(hex.slice(1,3),16);
      const gT = parseInt(hex.slice(3,5),16);
      const bT = parseInt(hex.slice(5,7),16);
      const hslT = rgbToHsl(rT,gT,bT);

      for (let i = 0, j = 0; i < data.length; i += 4, j++) {
        if (browMaskCache[j] === 0) continue;
        const r = data[i], g = data[i+1], b = data[i+2], a = data[i+3];
        const hslO = rgbToHsl(r,g,b);
        const [hh, ss, ll] = [hslT[0], Math.max(hslT[1], 0.15), hslO[2]];
        const [nr, ng, nb] = hslToRgb(hh, ss, ll);
        data[i] = nr; data[i+1] = ng; data[i+2] = nb; data[i+3] = a;
      }
      cctx.putImageData(id, 0, 0);
      const colored = new Image();
      colored.onload = () => { browImg = colored; colorApplied = true; draw(); };
      colored.src = c.toDataURL();
    }

    function snapshotFaceToDataURL() {
      const off = document.createElement("canvas");
      off.width = canvas.width; off.height = canvas.height;
      const octx = off.getContext("2d");
      if (faceImg) octx.drawImage(faceImg, 0, 0, off.width, off.height);
      return off.toDataURL();
    }
    function pushUndo() {
      const snap = snapshotFaceToDataURL();
      faceUndoStack.push(snap);
      if (faceUndoStack.length > MAX_UNDO) faceUndoStack.shift();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (faceImg) ctx.drawImage(faceImg, 0, 0, canvas.width, canvas.height);
      if (!browImg) return;
      const w = browImg.width * browScale;
      const h = browImg.height * browScale;
      ctx.save();
      ctx.translate(browPos.x, browPos.y);
      ctx.rotate(browAngle * Math.PI / 180);
      ctx.globalAlpha = alphaSlider.value / 255;
      ctx.drawImage(browImg, -w / 2, -h / 2, w, h);
      ctx.restore();
      ctx.globalAlpha = 1.0;
    }

    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h,s,l=(max+min)/2;
      if(max===min){ h=s=0; }
      else{
        const d=max-min; s=l>0.5? d/(2-max-min): d/(max+min);
        switch(max){
          case r: h=(g-b)/d+(g<b?6:0); break;
          case g: h=(b-r)/d+2; break;
          case b: h=(r-g)/d+4; break;
        } h/=6;
      }
      return [h,s,l];
    }
    function hslToRgb(h,s,l){
      let r,g,b;
      if(s===0){ r=g=b=l; }
      else{
        const hue2rgb=(p,q,t)=>{ if(t<0)t+=1; if(t>1)t-=1;
          if(t<1/6)return p+(q-p)*6*t;
          if(t<1/2)return q;
          if(t<2/3)return p+(q-p)*(2/3 - t)*6;
          return p; };
        const q=l<0.5? l*(1+s): l+s-l*s;
        const p=2*l-q;
        r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3);
      }
      return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
    }

    function uniqueEndpoints(connections) {
      const set = new Set();
      for (const [a,b] of connections) { set.add(a); set.add(b); }
      return Array.from(set);
    }
    function fillRegionHull(ctx2d, landmarks, idxList, W, H) {
      const pts = idxList.map(i => [landmarks[i].x * W, landmarks[i].y * H]);
      if (pts.length < 3) return;
      const hull = convexHull(pts);
      ctx2d.beginPath();
      ctx2d.moveTo(hull[0][0], hull[0][1]);
      for (let i=1;i<hull.length;i++) ctx2d.lineTo(hull[i][0], hull[i][1]);
      ctx2d.closePath();
      ctx2d.fill();
    }
    function convexHull(points) {
      points = points.slice().sort((a,b)=>a[0]===b[0]?a[1]-b[1]:a[0]-b[0]);
      const cross=(o,a,b)=>(a[0]-o[0])*(b[1]-o[1])-(a[1]-o[1])*(b[0]-o[0]);
      const lower=[]; for (const p of points){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop(); lower.push(p); }
      const upper=[]; for (let i=points.length-1;i>=0;i--){ const p=points[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop(); upper.push(p); }
      upper.pop(); lower.pop(); return lower.concat(upper);
    }

    // === E. 이벤트 ===
    faceInput.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        originalFaceSrc = evt.target.result;
        const img = new Image();
        img.onload = () => { faceImg = img; draw(); faceUndoStack = []; };
        img.src = originalFaceSrc;
      };
      reader.readAsDataURL(file);
    };

    browInput.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        const img = new Image();
        img.onload = async () => {
          originalBrowImg = img;
          const noWhite = removeWhite(img);
          browMaskCache = await buildBrowMask(noWhite);
          browImg = noWhite;
          draw();
          colorApplied = false;
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    };

    alphaSlider.oninput = draw;
    colorPicker.oninput = () => applyColorToBrow(colorPicker.value);

    resetBtn.onclick = () => {
      // 얼굴 원본 복원
      if (originalFaceSrc) {
        const img = new Image();
        img.onload = () => { faceImg = img; draw(); };
        img.src = originalFaceSrc;
      }
      // 추가 눈썹 제거
      browImg = null; originalBrowImg = null; browMaskCache = null;
      // 파라미터 초기화
      browScale = 1.0; browAngle = 0;
      browPos = { x: canvas.width / 2, y: canvas.height / 2 };
      colorPicker.value = "#000000"; alphaSlider.value = 255; colorApplied = false;
      draw();
    };

    undoBtn.onclick = () => {
      if (faceUndoStack.length === 0) { alert("되돌릴 항목이 없어요."); return; }
      const last = faceUndoStack.pop();
      const img = new Image();
      img.onload = () => { faceImg = img; draw(); };
      img.src = last;
    };

    // 마우스/휠
    canvas.addEventListener("mousedown", e => {
      if (!browImg) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const dx = mx - browPos.x;
      const dy = my - browPos.y;
      const w = browImg.width * browScale;
      const h = browImg.height * browScale;
      if (Math.abs(dx) < w/2 && Math.abs(dy) < h/2) { isDragging = true; offset = { x: dx, y: dy }; }
    });
    canvas.addEventListener("mousemove", e => {
      if (!isDragging) return;
      const rect = canvas.getBoundingClientRect();
      browPos.x = e.clientX - rect.left - offset.x;
      browPos.y = e.clientY - rect.top - offset.y;
      draw();
    });
    canvas.addEventListener("mouseup", () => { isDragging = false; });
    canvas.addEventListener("wheel", e => {
      e.preventDefault();
      if (!browImg) return;
      browScale *= (e.deltaY < 0) ? 1.05 : 0.95;
      if (browScale < 0.2) browScale = 0.2;
      draw();
    });
    document.addEventListener("keydown", e => {
      if (!browImg) return;
      if (e.key === "ArrowLeft") browAngle -= 2;
      else if (e.key === "ArrowRight") browAngle += 2;
      draw();
    });

    // 터치
    let lastTouchDist = null, lastTouchAngle = null;
    canvas.addEventListener("touchstart", e => {
      if (!browImg) return;
      e.preventDefault();
      if (e.touches.length === 1) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.touches[0].clientX - rect.left;
        const my = e.touches[0].clientY - rect.top;
        const dx = mx - browPos.x;
        const dy = my - browPos.y;
        const w = browImg.width * browScale;
        const h = browImg.height * browScale;
        if (Math.abs(dx) < w/2 && Math.abs(dy) < h/2) { isDragging = true; offset = { x: dx, y: dy }; }
      } else if (e.touches.length === 2) {
        const dx = e.touches[1].clientX - e.touches[0].clientX;
        const dy = e.touches[1].clientY - e.touches[0].clientY;
        lastTouchDist = Math.hypot(dx, dy);
        lastTouchAngle = Math.atan2(dy, dx);
      }
    }, { passive: false });
    canvas.addEventListener("touchmove", e => {
      if (!browImg) return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      if (e.touches.length === 1 && isDragging) {
        browPos.x = e.touches[0].clientX - rect.left - offset.x;
        browPos.y = e.touches[0].clientY - rect.top - offset.y;
        draw();
      } else if (e.touches.length === 2) {
        const dx = e.touches[1].clientX - e.touches[0].clientX;
        const dy = e.touches[1].clientY - e.touches[0].clientY;
        const dist = Math.hypot(dx, dy);
        const angle = Math.atan2(dy, dx);
        if (lastTouchDist !== null) {
          const scaleChange = dist / lastTouchDist;
          browScale *= scaleChange;
          if (browScale < 0.2) browScale = 0.2;
        }
        if (lastTouchAngle !== null) {
          const angleChange = angle - lastTouchAngle;
          browAngle += angleChange * (180 / Math.PI);
        }
        lastTouchDist = dist; lastTouchAngle = angle; draw();
      }
    }, { passive: false });
    canvas.addEventListener("touchend", e => {
      if (e.touches.length < 2) { lastTouchDist = null; lastTouchAngle = null; }
      if (e.touches.length === 0) { isDragging = false; }
    });

    // === F. 눈썹 자동 지우기 (얼굴) ===
    eraseBtn.onclick = async () => {
      if (!mpReady || !cvReady) { updateReady(); return; }
      if (!faceImg) { alert("먼저 얼굴 이미지를 업로드하세요."); return; }
      statusEl.textContent = "눈썹 지우는 중...";

      try {
        // 되돌리기 저장
        pushUndo();

        // 현재 얼굴 렌더
        const srcCan = document.createElement("canvas");
        srcCan.width = canvas.width; srcCan.height = canvas.height;
        const sctx = srcCan.getContext("2d");
        sctx.drawImage(faceImg, 0, 0, srcCan.width, srcCan.height);

        // 랜드마크
        const landmarks = await detectLandmarks(srcCan);
        if (!landmarks) { statusEl.textContent = "얼굴을 찾지 못했습니다."; return; }

        // 연결 상수 체크
        const L = (window.FACEMESH_LEFT_EYEBROW  || []);
        const R = (window.FACEMESH_RIGHT_EYEBROW || []);
        if (!L.length || !R.length) { console.warn('Eyebrow connections not loaded'); updateReady(); return; }

        // 마스크
        const maskCan = document.createElement("canvas");
        maskCan.width = srcCan.width; maskCan.height = srcCan.height;
        const mctx = maskCan.getContext("2d");
        mctx.fillStyle = "white";
        fillRegionHull(mctx, landmarks, uniqueEndpoints(L), srcCan.width, srcCan.height);
        fillRegionHull(mctx, landmarks, uniqueEndpoints(R), srcCan.width, srcCan.height);

        // 팽창/블러
        const maskImg = mctx.getImageData(0, 0, maskCan.width, maskCan.height);
        let maskMat = cv.matFromImageData(maskImg);
        cv.cvtColor(maskMat, maskMat, cv.COLOR_RGBA2GRAY);
        let kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(9, 9));
        cv.dilate(maskMat, maskMat, kernel);
        cv.GaussianBlur(maskMat, maskMat, new cv.Size(7,7), 0);
        cv.threshold(maskMat, maskMat, 10, 255, cv.THRESH_BINARY);

        // Inpaint
        const srcImgData = sctx.getImageData(0, 0, srcCan.width, srcCan.height);
        let srcMat = cv.matFromImageData(srcImgData);
        let dstMat = new cv.Mat();
        cv.cvtColor(srcMat, srcMat, cv.COLOR_RGBA2RGB);
        cv.inpaint(srcMat, maskMat, dstMat, 3, cv.INPAINT_TELEA);

        // 결과 반영
        let outRGBA = new cv.Mat();
        cv.cvtColor(dstMat, outRGBA, cv.COLOR_RGB2RGBA);
        const outCan = document.createElement("canvas");
        outCan.width = srcCan.width; outCan.height = srcCan.height;
        cv.imshow(outCan, outRGBA);

        const newFace = new Image();
        newFace.onload = () => { faceImg = newFace; draw(); statusEl.textContent = "준비 완료"; };
        newFace.src = outCan.toDataURL();

        // clean
        srcMat.delete(); dstMat.delete(); outRGBA.delete(); maskMat.delete(); kernel.delete();
      } catch (e) {
        console.error(e);
        statusEl.textContent = "실패: 콘솔 확인";
        alert("눈썹 지우기 중 오류가 발생했습니다.");
      }
    };
  </script>
</body>
</html>