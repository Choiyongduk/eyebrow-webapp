<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>íˆì¹ ëˆˆì¹ ë””ìì¸ ë¯¸ë¦¬ë³´ê¸°</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(to bottom, #ffe9d6, #fff3e6);
      display: flex;
      justify-content: center;
      padding: 20px;
    }
    .container { display: flex; flex-direction: row; align-items: flex-start; max-width: 1200px; width: 100%; }
    .controls {
      width: 280px; margin-right: 30px; background-color: #fff9f3; padding: 20px; border-radius: 12px;
      box-shadow: 0 0 10px rgba(0,0,0,0.05);
    }
    .controls h1 { color: #f2792b; font-size: 20px; margin-bottom: 20px; text-align: center; }
    .controls label { font-size: 14px; font-weight: bold; color: #333; }
    .controls input[type="file"] { margin-bottom: 15px; display: block; }
    .controls input[type="range"] { width: 100%; margin-bottom: 10px; }
    .controls input[type="color"] {
      width: 35px; height: 35px; border: none; border-radius: 50%; margin-bottom: 15px; padding: 0;
    }
    canvas { border: 4px solid #f2792b; border-radius: 16px; background-color: #fff; }
    button { background-color: #f2792b; color: white; border: none; padding: 8px 14px; font-size: 14px; border-radius: 6px; cursor: pointer; }
    button:hover { background-color: #d25e1d; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .muted { font-size: 12px; color: #666; margin-top: 6px;}
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <h1>íˆì¹ ëˆˆì¹ ë””ìì¸ ë¯¸ë¦¬ë³´ê¸°</h1>

      <label>ì–¼êµ´ ì´ë¯¸ì§€ ì—…ë¡œë“œ</label>
      <input type="file" id="faceInput" accept="image/*" />

      <label>ëˆˆì¹ ì´ë¯¸ì§€(PNG/JPG)</label>
      <input type="file" id="browInput" accept="image/*" />

      <label>ëˆˆì¹ íˆ¬ëª…ë„</label>
      <input type="range" id="alphaSlider" min="0" max="255" value="255" />

      <label>ëˆˆì¹ ìƒ‰ìƒ ì„ íƒ</label>
      <input type="color" id="colorPicker" />

      <div class="row">
        <button id="resetBtn">ë¦¬ì…‹</button>
        <button id="eraseBtn">ëˆˆì¹ ì§€ìš°ê¸°</button>
      </div>
      <div class="muted" id="status">ëª¨ë¸ ë¡œë”© ì¤‘...</div>
    </div>

    <canvas id="canvas" width="500" height="600"></canvas>
  </div>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <!-- MediaPipe FaceMesh (legacy) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

  <script>
    const faceInput = document.getElementById("faceInput");
    const browInput = document.getElementById("browInput");
    const alphaSlider = document.getElementById("alphaSlider");
    const colorPicker = document.getElementById("colorPicker");
    const resetBtn = document.getElementById("resetBtn");
    const eraseBtn = document.getElementById("eraseBtn");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");

    let faceImg = null;
    let browImg = null;
    let originalBrowImg = null;
    let browPos = { x: canvas.width / 2, y: canvas.height / 2 };
    let browScale = 1.0;
    let browAngle = 0;
    let isDragging = false;
    let offset = { x: 0, y: 0 };
    let colorApplied = false;
    let originalFaceSrc = null;

    // ====== MediaPipe FaceMesh ì¤€ë¹„ ======
    let faceMesh = null;
    let mpReady = false;
    let cvReady = false;

    function updateReady() {
      if (mpReady && cvReady) {
        statusEl.textContent = "ì¤€ë¹„ ì™„ë£Œ";
      }
    }

    // OpenCV ë¡œë”© ìƒíƒœ
    window.Module = {
      onRuntimeInitialized() {
        cvReady = true;
        updateReady();
      }
    };

    // FaceMesh ë¡œë”© ë° ì„¤ì •
    function initFaceMesh() {
      faceMesh = new FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
      });
      faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
        selfieMode: false
      });
      // onResultsëŠ” ìŠ¤íŠ¸ë¦¬ë°ìš© ì½œë°±. ì •ì  ì´ë¯¸ì§€ ì²˜ë¦¬ëŠ” Promiseë¡œ ê°ìŒˆ.
      mpReady = true;
      updateReady();
    }
    initFaceMesh();

    // ì •ì  ì´ë¯¸ì§€ì—ì„œ ëœë“œë§ˆí¬ ì¶”ì¶œ (Promise)
    function detectLandmarks(imageElOrCanvas) {
      return new Promise((resolve, reject) => {
        const fm = faceMesh;
        if (!fm) return reject(new Error("FaceMesh not ready"));
        fm.onResults((res) => {
          // í•œ ë²ˆ ê²°ê³¼ ë°›ê³  ì½œë°± í•´ì œ
          resolve(res && res.multiFaceLandmarks && res.multiFaceLandmarks[0] ? res.multiFaceLandmarks[0] : null);
        });
        fm.send({ image: imageElOrCanvas }).catch(reject);
      });
    }

    // ====== ê¸°ì¡´ ê¸°ëŠ¥ ======
    faceInput.onchange = e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = evt => {
    originalFaceSrc = evt.target.result;          // âœ… ì›ë³¸ ë³´ê´€
    faceImg = new Image();
    faceImg.onload = draw;
    faceImg.src = originalFaceSrc;                 // í‘œì‹œë„ ì›ë³¸ìœ¼ë¡œ
  };
  reader.readAsDataURL(file);
};

    browInput.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        const img = new Image();
        img.onload = () => {
          originalBrowImg = img;
          browImg = removeWhite(img);
          draw();
          colorApplied = false;
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    };

    function removeWhite(img) {
      const tempCanvas = document.createElement("canvas");
      const tempCtx = tempCanvas.getContext("2d");
      tempCanvas.width = img.width;
      tempCanvas.height = img.height;
      tempCtx.drawImage(img, 0, 0);
      const imgData = tempCtx.getImageData(0, 0, img.width, img.height);
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i + 1], b = data[i + 2];
        if (r > 220 && g > 220 && b > 220) data[i + 3] = 0;
      }
      tempCtx.putImageData(imgData, 0, 0);
      const result = new Image();
      result.src = tempCanvas.toDataURL();
      return result;
    }

    alphaSlider.oninput = draw;

    colorPicker.oninput = () => {
      if (!originalBrowImg) return;
      const canvasTemp = document.createElement("canvas");
      canvasTemp.width = originalBrowImg.width;
      canvasTemp.height = originalBrowImg.height;
      const ctxTemp = canvasTemp.getContext("2d");

      ctxTemp.drawImage(originalBrowImg, 0, 0);
      const imageData = ctxTemp.getImageData(0, 0, canvasTemp.width, canvasTemp.height);
      const data = imageData.data;
      const hex = colorPicker.value;
      const rNew = parseInt(hex.slice(1, 3), 16);
      const gNew = parseInt(hex.slice(3, 5), 16);
      const bNew = parseInt(hex.slice(5, 7), 16);

      for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] !== 0) {
          data[i] = rNew; data[i + 1] = gNew; data[i + 2] = bNew;
        }
      }
      ctxTemp.putImageData(imageData, 0, 0);
      browImg = new Image();
      browImg.onload = () => { draw(); colorApplied = true; };
      browImg.src = canvasTemp.toDataURL();
    };

    resetBtn.onclick = () => {
  // âœ… ì–¼êµ´: ì›ë³¸ìœ¼ë¡œ ë˜ëŒë¦¬ê¸° (ì§€ì›Œì¡Œë˜ ì‹¤ì œ ëˆˆì¹ ë³µì›)
  if (originalFaceSrc) {
    const img = new Image();
    img.onload = () => {
      faceImg = img;
      draw(); // ì–¼êµ´ ë¨¼ì € ë‹¤ì‹œ ê·¸ë¦¼
    };
    img.src = originalFaceSrc;
  }

  // âœ… ì¶”ê°€í•œ ëˆˆì¹(ê°€ì§œ) ì™„ì „íˆ ì‚­ì œ
  browImg = null;
  originalBrowImg = null;

  // âœ… ë³€í™˜/ì„¤ì •ê°’ ì´ˆê¸°í™”
  browScale = 1.0;
  browAngle = 0;
  browPos = { x: canvas.width / 2, y: canvas.height / 2 };
  colorPicker.value = "#000000";
  alphaSlider.value = 255;
  colorApplied = false;

  // ìº”ë²„ìŠ¤ ë‹¤ì‹œ ê·¸ë¦¼ (browImg ì—†ìœ¼ë‹ˆ ì–¼êµ´ë§Œ ë³´ì„)
  draw();
};

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (faceImg) ctx.drawImage(faceImg, 0, 0, canvas.width, canvas.height);
      if (!browImg) return;

      const w = browImg.width * browScale;
      const h = browImg.height * browScale;

      ctx.save();
      ctx.translate(browPos.x, browPos.y);
      ctx.rotate(browAngle * Math.PI / 180);
      ctx.globalAlpha = alphaSlider.value / 255;
      ctx.drawImage(browImg, -w / 2, -h / 2, w, h);
      ctx.restore();

      ctx.globalAlpha = 1.0;
    }

    // ğŸ–±ï¸ ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ & íœ 
    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const dx = mx - browPos.x;
      const dy = my - browPos.y;
      const w = browImg?.width * browScale || 0;
      const h = browImg?.height * browScale || 0;

      if (Math.abs(dx) < w / 2 && Math.abs(dy) < h / 2) {
        isDragging = true;
        offset = { x: dx, y: dy };
      }
    });

    canvas.addEventListener("mousemove", e => {
      if (!isDragging) return;
      const rect = canvas.getBoundingClientRect();
      browPos.x = e.clientX - rect.left - offset.x;
      browPos.y = e.clientY - rect.top - offset.y;
      draw();
    });

    canvas.addEventListener("mouseup", () => { isDragging = false; });

    canvas.addEventListener("wheel", e => {
      e.preventDefault();
      browScale *= (e.deltaY < 0) ? 1.05 : 0.95;
      if (browScale < 0.2) browScale = 0.2;
      draw();
    });

    document.addEventListener("keydown", e => {
      if (e.key === "ArrowLeft") browAngle -= 2;
      else if (e.key === "ArrowRight") browAngle += 2;
      draw();
    });

    // ğŸ“± ëª¨ë°”ì¼ ì œìŠ¤ì²˜
    let lastTouchDist = null, lastTouchAngle = null;
    canvas.addEventListener("touchstart", e => {
      if (!browImg) return;
      e.preventDefault();
      if (e.touches.length === 1) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.touches[0].clientX - rect.left;
        const my = e.touches[0].clientY - rect.top;
        const dx = mx - browPos.x;
        const dy = my - browPos.y;
        const w = browImg.width * browScale;
        const h = browImg.height * browScale;
        if (Math.abs(dx) < w / 2 && Math.abs(dy) < h / 2) {
          isDragging = true;
          offset = { x: dx, y: dy };
        }
      } else if (e.touches.length === 2) {
        const dx = e.touches[1].clientX - e.touches[0].clientX;
        const dy = e.touches[1].clientY - e.touches[0].clientY;
        lastTouchDist = Math.hypot(dx, dy);
        lastTouchAngle = Math.atan2(dy, dx);
      }
    }, { passive: false });

    canvas.addEventListener("touchmove", e => {
      if (!browImg) return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();

      if (e.touches.length === 1 && isDragging) {
        browPos.x = e.touches[0].clientX - rect.left - offset.x;
        browPos.y = e.touches[0].clientY - rect.top - offset.y;
        draw();
      } else if (e.touches.length === 2) {
        const dx = e.touches[1].clientX - e.touches[0].clientX;
        const dy = e.touches[1].clientY - e.touches[0].clientY;
        const dist = Math.hypot(dx, dy);
        const angle = Math.atan2(dy, dx);

        if (lastTouchDist !== null) {
          const scaleChange = dist / lastTouchDist;
          browScale *= scaleChange;
          if (browScale < 0.2) browScale = 0.2;
        }

        if (lastTouchAngle !== null) {
          const angleChange = angle - lastTouchAngle;
          browAngle += angleChange * (180 / Math.PI);
        }

        lastTouchDist = dist;
        lastTouchAngle = angle;
        draw();
      }
    }, { passive: false });

    canvas.addEventListener("touchend", e => {
      if (e.touches.length < 2) {
        lastTouchDist = null;
        lastTouchAngle = null;
      }
      if (e.touches.length === 0) { isDragging = false; }
    });

    // ====== í•µì‹¬: ëˆˆì¹ ìë™ ì§€ìš°ê¸° ======
    eraseBtn.onclick = async () => {
      try {
        if (!faceImg) { alert("ë¨¼ì € ì–¼êµ´ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”."); return; }
        if (!mpReady || !cvReady) { alert("ëª¨ë¸ ë¡œë”© ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œìš”!"); return; }
        statusEl.textContent = "ëˆˆì¹ ì§€ìš°ëŠ” ì¤‘...";

        // 1) ë””ìŠ¤í”Œë ˆì´ í¬ê¸°(500x600)ì— ë§ì¶° ì–¼êµ´ë§Œ ì˜¤í”„ìŠ¤í¬ë¦°ì— ë Œë”
        const srcCan = document.createElement("canvas");
        srcCan.width = canvas.width; srcCan.height = canvas.height;
        const sctx = srcCan.getContext("2d");
        sctx.drawImage(faceImg, 0, 0, srcCan.width, srcCan.height);

        // 2) ëœë“œë§ˆí¬ ì¶”ì¶œ
        const landmarks = await detectLandmarks(srcCan);
        if (!landmarks) { statusEl.textContent = "ì–¼êµ´ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."; return; }

        // 3) ëˆˆì¹ ì˜ì—­ ë§ˆìŠ¤í¬ ìƒì„±
        // MediaPipe FaceMeshì—ëŠ” FACEMESH_LEFT_EYEBROW / FACEMESH_RIGHT_EYEBROW ì—°ê²°ì´ ìˆìŒ.
        // ì—°ê²°ì˜ ì–‘ ë ì ë“¤ì„ ëª¨ì•„ ì»¨ë²¡ìŠ¤ í—ë¡œ ì±„ì›€.
        const lPts = uniqueEndpoints(window.FACEMESH_LEFT_EYEBROW || []);
        const rPts = uniqueEndpoints(window.FACEMESH_RIGHT_EYEBROW || []);

        const maskCan = document.createElement("canvas");
        maskCan.width = srcCan.width; maskCan.height = srcCan.height;
        const mctx = maskCan.getContext("2d");
        mctx.fillStyle = "white";

        // ì¢Œ/ìš° ëˆˆì¹ í´ë¦¬ê³¤ ì±„ìš°ê¸° (ê°„ë‹¨íˆ: ì—°ê²°ì ë“¤ì˜ ì»¨ë²¡ìŠ¤í—)
        fillRegionHull(mctx, landmarks, lPts, srcCan.width, srcCan.height);
        fillRegionHull(mctx, landmarks, rPts, srcCan.width, srcCan.height);

        // íŒ½ì°½ íš¨ê³¼: ë§ˆìŠ¤í¬ë¥¼ ì‚´ì§ ë‘ê»ê²Œ (ë¸”ëŸ¬ í›„ ë°”ì´ë„ˆë¦¬í™”)
        const maskImg = mctx.getImageData(0, 0, maskCan.width, maskCan.height);
        // OpenCVë¡œ íŒ½ì°½ & ë¸”ëŸ¬
        let maskMat = cv.matFromImageData(maskImg);
        cv.cvtColor(maskMat, maskMat, cv.COLOR_RGBA2GRAY);
        let kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(9, 9));
        cv.dilate(maskMat, maskMat, kernel);
        cv.GaussianBlur(maskMat, maskMat, new cv.Size(7,7), 0);
        cv.threshold(maskMat, maskMat, 10, 255, cv.THRESH_BINARY);

        // 4) Inpaint
        const srcImgData = sctx.getImageData(0, 0, srcCan.width, srcCan.height);
        let srcMat = cv.matFromImageData(srcImgData);
        let dstMat = new cv.Mat();
        cv.cvtColor(srcMat, srcMat, cv.COLOR_RGBA2RGB);
        cv.inpaint(srcMat, maskMat, dstMat, 3, cv.INPAINT_TELEA);

        // 5) ê²°ê³¼ë¥¼ faceImgë¡œ ë°˜ì˜
        let outRGBA = new cv.Mat();
        cv.cvtColor(dstMat, outRGBA, cv.COLOR_RGB2RGBA);
        const outCan = document.createElement("canvas");
        outCan.width = srcCan.width; outCan.height = srcCan.height;
        cv.imshow(outCan, outRGBA);

        faceImg = new Image();
        faceImg.onload = () => { draw(); statusEl.textContent = "ì¤€ë¹„ ì™„ë£Œ"; };
        faceImg.src = outCan.toDataURL();

        // clean
        srcMat.delete(); dstMat.delete(); outRGBA.delete(); maskMat.delete(); kernel.delete();

      } catch (err) {
        console.error(err);
        statusEl.textContent = "ì‹¤íŒ¨: ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.";
        alert("ëˆˆì¹ ì§€ìš°ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }
    };

    // ì—°ê²° ë¦¬ìŠ¤íŠ¸ì—ì„œ ì—”ë“œí¬ì¸íŠ¸ ì¸ë±ìŠ¤ ì§‘í•© êµ¬í•˜ê¸°
    function uniqueEndpoints(connections) {
      const set = new Set();
      for (const [a,b] of connections) { set.add(a); set.add(b); }
      return Array.from(set);
    }

    // ì ë“¤ì˜ ì»¨ë²¡ìŠ¤ í—ì„ ê·¸ë ¤ ì±„ìš°ê¸°
    function fillRegionHull(ctx2d, landmarks, idxList, W, H) {
      const pts = idxList.map(i => [landmarks[i].x * W, landmarks[i].y * H]);
      if (pts.length < 3) return;
      const hull = convexHull(pts);
      ctx2d.beginPath();
      ctx2d.moveTo(hull[0][0], hull[0][1]);
      for (let i=1;i<hull.length;i++) ctx2d.lineTo(hull[i][0], hull[i][1]);
      ctx2d.closePath();
      ctx2d.fill();
    }

    // Graham scan (ê°„ë‹¨ ì»¨ë²¡ìŠ¤í—)
    function convexHull(points) {
      points = points.slice().sort((a,b)=>a[0]===b[0]?a[1]-b[1]:a[0]-b[0]);
      const cross = (o,a,b)=>(a[0]-o[0])*(b[1]-o[1])-(a[1]-o[1])*(b[0]-o[0]);
      const lower=[];
      for (const p of points){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop(); lower.push(p); }
      const upper=[];
      for (let i=points.length-1;i>=0;i--){ const p=points[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop(); upper.push(p); }
      upper.pop(); lower.pop();
      return lower.concat(upper);
    }
  </script>
</body>
</html>